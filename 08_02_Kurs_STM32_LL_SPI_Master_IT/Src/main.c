/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "main.h"
#include "W25Q64_flash.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define SIZE_BUFFER	256

typedef enum
{
	READ_1 = 0,
	WRITE,
	READ_2,
	WAIT,
	STOP
}state_t;

uint8_t read_buffer_1[SIZE_BUFFER];
uint8_t read_buffer_2[SIZE_BUFFER];
uint8_t write_buffer[SIZE_BUFFER];

volatile state_t state = READ_1;

int main(void)
{
	rcc_init();
	spi_init();

	for (uint32_t i = 0; i < SIZE_BUFFER; i++)
	{
		write_buffer[i] = i;
	}

	W25Q64_Init();
	W25Q64_SectorErase(0);

	while (1)
	{
		if(state == READ_1)
		{
			state = WAIT;
			W25Q64_ReadDataBytes(0x0000, read_buffer_1, SIZE_BUFFER);
		}
		else if(state == WRITE)
		{
			state = WAIT;
			W25Q64_PageProgram(0x0000, write_buffer, SIZE_BUFFER);
		}
		else if(state == READ_2)
		{
			state = STOP;
			W25Q64_ReadDataBytes(0x0000, read_buffer_2, SIZE_BUFFER);
		}
	}
}

void spi_transfer_cplt_callback(transfer_type_t type)
{
	if(type == TRANSMIT && state == WAIT)
	{
		state = READ_2;
	}
	else if(type == RECEIVE && state == WAIT)
	{
		state = WRITE;
	}
}

void rcc_init(void)
{
	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);

	LL_RCC_HSI_Enable();
	while(LL_RCC_HSI_IsReady() != 1)
		;

	LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);

	LL_RCC_PLL_Enable();
	while(LL_RCC_PLL_IsReady() != 1)
		;

	LL_RCC_PLL_EnableDomain_SYS();

	LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);

	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
	while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
		;

	LL_SetSystemCoreClock(64000000);
	LL_Init1msTick(64000000);
	LL_SYSTICK_EnableIT();
}
